(function() {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const s of document.querySelectorAll('link[rel="modulepreload"]')) i(s);
  new MutationObserver(s => {
    for (const o of s)
      if (o.type === "childList")
        for (const n of o.addedNodes) n.tagName === "LINK" && n.rel === "modulepreload" && i(n)
  }).observe(document, {
    childList: !0,
    subtree: !0
  });

  function t(s) {
    const o = {};
    return s.integrity && (o.integrity = s.integrity), s.referrerPolicy && (o.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? o.credentials = "include" : s.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o
  }

  function i(s) {
    if (s.ep) return;
    s.ep = !0;
    const o = t(s);
    fetch(s.href, o)
  }
})();
let P = class {
  constructor(e) {
    this.scene = e, this.connections = [], this.connectionGeometry = new THREE.CylinderGeometry(.1, .1, 1, 4), this.connectionMaterial = new THREE.MeshBasicMaterial, this.connectionWeights = [], this.connectionSourceIndices = [], this.connectionTargetIndices = []
  }
  createConnections(e, t, i = null, s = "full") {
    const o = e.length * t.length,
      n = new THREE.InstancedMesh(this.connectionGeometry, this.connectionMaterial.clone(), o);
    n.material.transparent = !0, n.material.opacity = .5, n.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(o * 3), 3);
    const r = new THREE.Matrix4;
    let a = 0;
    const l = [],
      c = [],
      d = [];
    if (i) {
      const u = [];
      for (let f = 0; f < i.length; f++)
        for (let w = 0; w < i[f].length; w++) u.push(Math.abs(i[f][w]));
      const h = Math.max(...u),
        g = Math.min(...u),
        m = h - g;
      i.map(f => f.map(w => m > 0 ? (Math.abs(w) - g) / m : .5))
    }
    for (let u = 0; u < e.length; u++)
      for (let h = 0; h < t.length; h++) {
        const g = e[u],
          m = t[h],
          f = new THREE.Vector3(g.x, g.y, g.z),
          w = new THREE.Vector3(m.x, m.y, m.z),
          b = f.distanceTo(w),
          p = f.clone().add(w).multiplyScalar(.5);
        r.makeScale(1, b, 1), r.setPosition(p.x, p.y, p.z);
        const C = w.clone().sub(f).normalize();
        if (Math.abs(C.y) < .99) {
          const E = new THREE.Vector3(0, 1, 0),
            v = new THREE.Quaternion().setFromUnitVectors(E, C);
          r.makeRotationFromQuaternion(v), r.setPosition(p.x, p.y, p.z), r.scale(new THREE.Vector3(1, b, 1))
        }
        n.setMatrixAt(a, r), i ? l.push(i[u][h]) : l.push(0), c.push(u), d.push(h), n.setColorAt(a, new THREE.Color(.1, .1, .1)), a++
      }
    return n.userData = {
      weights: l,
      sourceIndices: c,
      targetIndices: d
    }, n.instanceColor.needsUpdate = !0, this.scene.add(n), this.connections.push(n), n
  }
  weightToColor(e) {
    if (e < .991) {
      const t = e * 2;
      return new THREE.Color(t, t, 1)
    } else {
      const t = (e - .5) * 2;
      return new THREE.Color(1, 1 - t, 1 - t)
    }
  }
  updateConnectionOpacity(e, t) {
    e && e.material && (e.material.opacity = t, e.material.needsUpdate = !0)
  }
  updateConnectionActivations(e, t, i, s = .1) {
    if (!e || !e.userData) return;
    const {
      weights: o,
      sourceIndices: n,
      targetIndices: r
    } = e.userData, a = e.count;
    for (let l = 0; l < a; l++) {
      const c = n[l],
        d = r[l],
        u = o[l];
      if (c >= t.length || d >= i.length) continue;
      const h = t[c],
        g = i[d],
        m = h * u,
        f = Math.abs(h) > s,
        w = Math.abs(g) > s,
        b = m > 0;
      if (f && w && b) {
        const p = Math.min(1, Math.abs(m)),
          C = this.weightToColor(p);
        e.setColorAt(l, C)
      } else e.setColorAt(l, new THREE.Color(.1, .1, .1))
    }
    e.instanceColor.needsUpdate = !0
  }
  dispose() {
    this.connections.forEach(e => {
      this.scene.remove(e), e.dispose()
    }), this.connections = []
  }
};
window.DenseLayerConnections = P;
let D = class {
  constructor() {
    this.filters = [
      [
        [
          [.6129415035247803]
        ],
        [
          [.429759681224823]
        ],
        [
          [.2544291913509369]
        ]
      ],
      [
        [
          [.09932208061218262]
        ],
        [
          [.6986075639724731]
        ],
        [
          [.7215195298194885]
        ]
      ],
      [
        [
          [.6055720448493958]
        ],
        [
          [.7132970094680786]
        ],
        [
          [.9554887413978577]
        ]
      ]
    ], this.biases = [.005940103437751532], this.filters2 = [
      [
        [
          [-.5782387256622314, -.22326283156871796]
        ],
        [
          [.4236845076084137, -.4443149268627167]
        ],
        [
          [.43697747588157654, -.8734493255615234]
        ]
      ],
      [
        [
          [.23330314457416534, .8764686584472656]
        ],
        [
          [.38114675879478455, .8586363792419434]
        ],
        [
          [-.0766456350684166, .580498993396759]
        ]
      ],
      [
        [
          [.27924683690071106, -.4435594081878662]
        ],
        [
          [.2150324583053589, -.0011785480892285705]
        ],
        [
          [.2214050143957138, .3177492916584015]
        ]
      ]
    ], this.biases2 = [-.6145215630531311, -.2805446684360504]
  }
  applyConvolution(e, t) {
    if (t < 0 || t >= this.biases.length) throw new Error(`Channel index ${t} out of bounds. Only ${this.biases.length} channels available.`);
    const i = e.length,
      s = e[0].length;
    if (i < 3 || s < 3) return [];
    const o = i - 2,
      n = s - 2,
      r = this.filters[0][0][0][t],
      a = this.filters[0][1][0][t],
      l = this.filters[0][2][0][t],
      c = this.filters[1][0][0][t],
      d = this.filters[1][1][0][t],
      u = this.filters[1][2][0][t],
      h = this.filters[2][0][0][t],
      g = this.filters[2][1][0][t],
      m = this.filters[2][2][0][t],
      f = this.biases[t],
      w = new Array(o);
    for (let b = 0; b < o; b++) {
      const p = e[b],
        C = e[b + 1],
        E = e[b + 2],
        v = new Array(n);
      for (let y = 0; y < n; y++) v[y] = p[y] * r + p[y + 1] * a + p[y + 2] * l + C[y] * c + C[y + 1] * d + C[y + 2] * u + E[y] * h + E[y + 1] * g + E[y + 2] * m + f;
      w[b] = v
    }
    return w
  }
  applyMaxPooling(e, t = 2) {
    const i = e.length,
      s = e[0].length,
      o = Math.floor(i / t),
      n = Math.floor(s / t),
      r = [];
    for (let a = 0; a < o; a++) {
      r[a] = [];
      for (let l = 0; l < n; l++) {
        let c = -1 / 0;
        for (let d = 0; d < t; d++)
          for (let u = 0; u < t; u++) {
            const h = a * t + d,
              g = l * t + u;
            if (h < i && g < s) {
              const m = e[h][g];
              typeof m == "number" && !isNaN(m) && (c = Math.max(c, m))
            }
          }
        r[a][l] = c === -1 / 0 ? 0 : c
      }
    }
    return r
  }
  applyReLUActivation(e) {
    return e.map(t => t.map(i => Math.max(0, i)))
  }
  normalizeForColor(e) {
    const t = [];
    for (let n = 0; n < e.length; n++)
      for (let r = 0; r < e[n].length; r++) typeof e[n][r] == "number" && !isNaN(e[n][r]) && t.push(e[n][r]);
    if (t.length === 0) return e.map(n => n.map(() => .5));
    const i = Math.min(...t),
      o = Math.max(...t) - i;
    return o === 0 ? e.map(n => n.map(() => .5)) : e.map(n => n.map(r => typeof r == "number" && !isNaN(r) ? (r - i) / o : .5))
  }
  valueToColor(e) {
    const t = Math.max(0, Math.min(1, e * 2 - 1)),
      i = Math.max(0, Math.min(1, 1 - Math.abs(e * 2 - 1))),
      s = Math.max(0, Math.min(1, 1 - e * 2));
    return new THREE.Color(t, i, s)
  }
  applyConvolution2(e, t) {
    if (t >= this.biases2.length) throw new Error(`Channel index ${t} out of bounds. Only ${this.biases2.length} channels available.`);
    const i = this.biases2[t],
      s = e.length,
      o = e[0].length,
      n = e[0][0].length,
      r = o - 2,
      a = n - 2,
      l = [];
    for (let c = 0; c < r; c++) {
      l[c] = [];
      for (let d = 0; d < a; d++) l[c][d] = 0
    }
    for (let c = 0; c < r; c++)
      for (let d = 0; d < a; d++) {
        let u = 0;
        for (let h = 0; h < s; h++) {
          const g = e[h];
          for (let m = 0; m < 3; m++)
            for (let f = 0; f < 3; f++) {
              const w = c + m,
                b = d + f,
                p = g[w][b];
              let C = 0;
              typeof p == "number" ? C = p : Array.isArray(p) ? C = p.length === 1 ? p[0] : (p[0] + p[1] + p[2]) / 3 : C = 0;
              const E = this.filters2[m][f][h][t];
              u += C * E
            }
        }
        l[c][d] = u + i
      }
    return l
  }
};
window.ConvolutionUtils = D;
let I = class {
  static getDense1Weights() {
    return [
      [-.654028058052063, -.08121760934591293, -.15505413711071014, .1358015537261963, -.05571679398417473, -.050745896995067596, -.13195300102233887, -.3038172125816345, -.08200835436582565, .19272004067897797, .43610531091690063, .21719574928283691, -.22069725394248962, .3922116756439209, .09404371678829193, .150979146361351, -.07880197465419769, -.014881410636007786, -.45976173877716064, .2002025544643402, .21520209312438965, -.06735032051801682],
      [-.25937220454216003, -.14474724233150482, -.5010589957237244, -.10789396613836288, .13517828285694122, -.12606845796108246, -.17070908844470978, .3019596338272095, .13999471068382263, .2606348991394043, .22431005537509918, .16747498512268066, .06656652688980103, -.07737407833337784, .13004249334335327, -.9368721842765808, -.11455973237752914, .003953744191676378, -.1039186641573906, .028632579371333122, .07254227995872498, .062376104295253754],
      [-.40165963768959045, .03977649658918381, -.07812312990427017, -.11596578359603882, -.308230996131897, -.0745130181312561, .04077607020735741, -.15143609046936035, .06820695102214813, .08381792157888412, -.10861257463693619, .17806512117385864, .17098942399024963, .17463496327400208, .1398860067129135, -.534267246723175, -.10959025472402573, .18640737235546112, -.21089543402194977, -.10220561921596527, .04052753746509552, .015542509965598583],
      [-.6090140342712402, .14523638784885406, -.11215926706790924, .19565559923648834, -.010337447747588158, -.0095907524228096, -.16345743834972382, .13513924181461334, -.11955682933330536, -.09960594028234482, .19710269570350647, -.14833194017410278, .2421049177646637, -.4182559549808502, -.16589325666427612, -.9187639951705933, .16080699861049652, -.14042311906814575, .23265764117240906, .24877139925956726, -.07007361948490143, .17706826329231262],
      [.6447916030883789, .02121456153690815, .10481145232915878, -.11053676158189774, -.35558563470840454, .22231915593147278, .09268158674240112, -.3910309970378876, .04980575293302536, -.028381437063217163, -.11626208573579788, .13367779552936554, .22560566663742065, .0599013976752758, .24915774166584015, -.22208166122436523, .06417809426784515, -.0875677838921547, .11887669563293457, 7689610356464982e-20, -.09319189935922623, .11563520133495331],
      [-.035738568753004074, -.02508588694036007, .21891023218631744, .22945758700370789, .2998347580432892, -.10170208662748337, .11241638660430908, -.06981106102466583, -.11239767074584961, .34447115659713745, -.053769540041685104, .22587592899799347, .08707907795906067, -.3623872399330139, -.16639497876167297, -.08651526272296906, -.14026841521263123, .2917037606239319, .5288518667221069, .13356976211071014, .425875186920166, .3808058500289917],
      [.3548484146595001, .016700536012649536, .4384985566139221, .021838944405317307, -.08279141038656235, .28885865211486816, -.09354658424854279, .09188805520534515, -.23133176565170288, -.21866820752620697, -.30167925357818604, .18908900022506714, .33526375889778137, .09545812755823135, .39648157358169556, .4805179238319397, -.05270405113697052, -.1602267324924469, -.108905129134655, .02663555182516575, -.08440043777227402, .15491680800914764],
      [-.5473337173461914, .12152037769556046, .28496694564819336, -.00017832816229201853, .1109178364276886, .7810052037239075, .12153579294681549, -.13666844367980957, .15981155633926392, -.1480095237493515, -.09197795391082764, -.07104925811290741, .44803616404533386, -.3610963523387909, -.24900175631046295, .3507058024406433, .1707083284854889, .08954545855522156, .4336276650428772, -.07672270387411118, -.22591039538383484, .5113994479179382],
      [.29961660504341125, -.09103046357631683, .16123010218143463, .0842820554971695, .10365419834852219, -.03578764200210571, -.16253815591335297, .2744121253490448, .1735534816980362, .1709461510181427, .1026344895362854, -.10026779025793076, -.04047444462776184, .07691512256860733, -.3446428179740906, .48186975717544556, .23240520060062408, -.23763342201709747, -.05934731662273407, .455093115568161, -.4082793593406677, .23957394063472748],
      [.2784622013568878, .38571929931640625, .4254415035247803, .01632694900035858, .19289614260196686, .16943763196468353, .15832427144050598, -.28776872158050537, .43257012963294983, -.129551962018013, -.10079589486122131, .08060410618782043, .19214385747909546, .06993350386619568, -.40969187021255493, .39539745450019836, -.3269181251525879, -.025753553956747055, .1523497849702835, .5716509819030762, -.4183310270309448, .4920862019062042],
      [-.21469880640506744, .3009595572948456, .4653145372867584, -.6112556457519531, .01680830866098404, -.053078241646289825, -.005023262929171324, .15320169925689697, .11252111196517944, -.15858817100524902, -.17199428379535675, -.2916581630706787, -.7183451652526855, .0810694471001625, -.14232812821865082, -.630519688129425, -.06679662317037582, .24748949706554413, .1711415946483612, -.26714563369750977, .05771637707948685, .2856189012527466],
      [.08271028846502304, -.016208061948418617, -.30561506748199463, -.28968119621276855, -.005305409897118807, -.002808240707963705, -.4293753206729889, .30241256952285767, -.4283525049686432, .26785898208618164, -.1791786402463913, -.23118261992931366, .49538591504096985, -.2585623562335968, .2301604002714157, .06567855179309845, .03573473170399666, .2510150969028473, .12355037778615952, .19612346589565277, .571942925453186, -.10838549584150314],
      [.24682392179965973, .2914668619632721, .28222230076789856, -.5402362942695618, .35873788595199585, -.1718227118253708, .34814581274986267, .4016999304294586, .3712286353111267, .1628217250108719, -.27823665738105774, -.012888478115200996, -.3114981949329376, -.12556099891662598, -.029864199459552765, .026650456711649895, -.3172125816345215, .19795970618724823, -.019287366420030594, -.37551480531692505, -.25895488262176514, .4421328604221344],
      [-.423404335975647, .04191796854138374, -.20256412029266357, -.2539708912372589, .40849417448043823, .23353733122348785, -.1331564038991928, .4640066623687744, -.14514964818954468, -.16522911190986633, -.27451092004776, -.25729623436927795, .07638421654701233, .20507976412773132, -.19369041919708252, -.5077956318855286, -.12619109451770782, .13011053204536438, .19050686061382294, .6419695019721985, .16238074004650116, .17363154888153076],
      [.16574129462242126, .2691200375556946, -.008424618281424046, -.0008329702541232109, .20964552462100983, -.4168103337287903, -.017643000930547714, .15213796496391296, .40736523270606995, .2881149351596832, .1661376655101776, -.2647510766983032, -.6301191449165344, .06118154525756836, -.10916528850793839, .17910340428352356, -.16529731452465057, -.1437690258026123, .2980159819126129, -.3293364346027374, .4857836961746216, -.057452309876680374],
      [.13716664910316467, .05369497463107109, -.6078470349311829, .010659550316631794, .5808359980583191, .10679692029953003, -.07150382548570633, -.2396620810031891, .27153652906417847, .010961543768644333, -.09539889544248581, .1556604951620102, -.14262321591377258, .042236361652612686, -.3147897720336914, -.2645946443080902, -.12230860441923141, -.044858552515506744, .3685210347175598, -.2998456656932831, -.0468117892742157, .04020001366734505],
      [.020245477557182312, -.4018985629081726, -.22497418522834778, -.10191527009010315, -.30438515543937683, .11377376317977905, -.12023545801639557, .18811200559139252, .008703498169779778, -.061061955988407135, .8379349708557129, .17513476312160492, -.06146153807640076, .1880001723766327, .06846655905246735, -.15228576958179474, -.10338997095823288, -.12565739452838898, .37830039858818054, .16763493418693542, .23284536600112915, -.6847017407417297],
      [-.23574252426624298, .44193828105926514, -.008049027994275093, .13606417179107666, .6303671002388, -.1613278090953827, .06854977458715439, -.28777194023132324, .2921489477157593, -.25143593549728394, -.1496136486530304, -.037257105112075806, .2524210810661316, .6392804384231567, .09713567793369293, .14684517681598663, .12186210602521896, .09222926944494247, .2605830729007721, -.06986545771360397, -.2901879549026489, -.20444774627685547],
      [.29735735058784485, .058505501598119736, -.009459658525884151, .03203630447387695, -.294541597366333, -.18408064544200897, -.23860777914524078, .29466789960861206, .17821592092514038, -.062334589660167694, .16695968806743622, -.13890083134174347, -.03825407102704048, .18953725695610046, .1554020196199417, -.2203185111284256, -.07673606276512146, -.10716772079467773, .077013298869133, .08575823903083801, .035852786153554916, -.34422725439071655],
      [-.1712265908718109, .13671094179153442, .0780939906835556, .1694735437631607, .1358295977115631, .25479429960250854, .2388066053390503, -.1824691891670227, .7897095680236816, -.08032507449388504, -.3685208857059479, -.24992536008358002, -.15577590465545654, .8924626111984253, -.16471362113952637, -.22919848561286926, -.266916960477829, -.11356131732463837, -.03099985048174858, -.22462119162082672, -.12811586260795593, -.5974007844924927],
      [-.060636021196842194, -.13722865283489227, .47039785981178284, -.33302247524261475, -.0326744019985199, -.282407283782959, .305093377828598, .3828609883785248, -.2360646277666092, -.16105929017066956, .046328529715538025, -.024215498939156532, -.36748266220092773, .4952891170978546, .008496462367475033, -.11979086697101593, .22372399270534515, -.24546846747398376, -.25278154015541077, -.33358919620513916, -.03230610862374306, -.07700345665216446],
      [-.18631413578987122, .23595964908599854, -.4167025089263916, .5592626333236694, -.041504405438899994, .2874043583869934, -.30948424339294434, .3069080710411072, -.10670439898967743, -.3163301348686218, -.03666254132986069, .011883764527738094, .2946423292160034, -.23083198070526123, -.02681315317749977, -.5346240997314453, .22863860428333282, .19535529613494873, .1265147179365158, .01260113064199686, .5238139629364014, -.20326609909534454],
      [.3353094160556793, .07318870723247528, .6429393887519836, -.17268727719783783, -.1600854992866516, -.4068796634674072, -.11515478789806366, .2999590337276459, -.12122676521539688, .27638936042785645, .41566476225852966, .05598096549510956, -.5062980055809021, .16552519798278809, -.2874210774898529, .10939739644527435, .18977642059326172, -.4625016450881958, -.04765995964407921, -.12664297223091125, .02520882338285446, -.3293262720108032],
      [-.15887266397476196, -.42158243060112, .2594256103038788, .6065718531608582, .45123377442359924, .32464560866355896, .2755458354949951, .6789803504943848, .22278442978858948, .271279513835907, -.0998072624206543, -.05757386237382889, .4997398257255554, .03498769551515579, .09322971105575562, -.2672891914844513, -.3091966211795807, .3279268443584442, -.0028420896269381046, -.29541125893592834, -.26856425404548645, -.21775008738040924],
      [.029035013169050217, .06091682240366936, .05010043457150459, .11835911124944687, -.05217115953564644, -.3923111855983734, -.26572155952453613, -.19183862209320068, -.11664175242185593, .3805080056190491, .3919585049152374, -.17599846422672272, .14361348748207092, .03693590685725212, .45190563797950745, .0763181522488594, -.46882307529449463, -.20515739917755127, .36202728748321533, .18854841589927673, .3294272720813751, -.45704057812690735],
      [-.03138037398457527, -1.0783027410507202, -.074225053191185, .22325602173805237, .2299722582101822, .12587398290634155, .3204145133495331, .21137231588363647, .09716024994850159, .013983459211885929, .11665146052837372, -.2305441051721573, -.4102133810520172, -.3256669044494629, .30935728549957275, -.08371799439191818, -.2864587903022766, -.08222613483667374, .11266470700502396, .34294143319129944, -.33803462982177734, .3998207449913025],
      [-.1707935631275177, -.09714309871196747, .2190847098827362, -.5446441173553467, .08798525482416153, .7465298771858215, -.049321942031383514, -.02935384027659893, -.14841009676456451, .4295538365840912, .22551606595516205, -.206294983625412, .5312696695327759, -.6062527894973755, .2847461402416229, .18231265246868134, .17537279427051544, .4335995316505432, .07320504635572433, .14279599487781525, -.3978409767150879, -.3392072916030884],
      [.1310322880744934, -.538192629814148, .4138782024383545, .20794591307640076, .22302916646003723, -.4189302623271942, -.15216752886772156, -.3101262152194977, .24298040568828583, -.21968837082386017, .23579232394695282, -.1680903285741806, -.24031619727611542, .03629288077354431, .3931178152561188, .08970769494771957, -.5184982419013977, -.08332566171884537, -.042622748762369156, .08601489663124084, -.12231209874153137, .11847469955682755],
      [-.2561127543449402, -.06527145951986313, .10566426813602448, -.6288554668426514, -.031919535249471664, .7945126295089722, .060277167707681656, .3559449315071106, -.08543556928634644, .3230063021183014, .1372217983007431, -.12959115207195282, .11408957839012146, -.45421740412712097, -.11882748454809189, .24364909529685974, .016150254756212234, .42934826016426086, .2850334942340851, .31916525959968567, .1017143726348877, .13720327615737915],
      [-.20238818228244781, -.38332319259643555, .2199452966451645, -.1379060447216034, -.055046435445547104, -.3113073408603668, .05574936047196388, -.0702795460820198, .08758677542209625, .006898950319737196, -.13239280879497528, -.2183549553155899, -.08859331905841827, .1462973654270172, .12669900059700012, .06785482168197632, -.3424680531024933, .04685842990875244, -.11884423345327377, .5323877334594727, .14451855421066284, .36829546093940735],
      [-.042857974767684937, -.2890252470970154, .07352408021688461, .4937439262866974, -.10960020869970322, .14367051422595978, .6621788144111633, -.06832318753004074, -.44397714734077454, -.4645662009716034, .05808328837156296, -.1261761635541916, -.24968643486499786, -.032587841153144836, -.16970045864582062, .044503360986709595, .07680009305477142, -.06538629531860352, -.239615797996521, -.12363723665475845, -.0040678540244698524, -.008262541145086288],
      [-.09890773147344589, -.10830066353082657, -.28577858209609985, .8425820469856262, .19574132561683655, -.04495558515191078, -.30091172456741333, -.2997887134552002, .2689485549926758, -1.2423810958862305, -.07286688685417175, -.2642957270145416, .2412877082824707, -.06459937989711761, .413168340921402, -.5171830654144287, -.12936294078826904, -.163741335272789, .2149222493171692, .03846224024891853, .027770303189754486, -.18168029189109802],
      [-.032006748020648956, -.03484983369708061, -.29294559359550476, -.021262267604470253, -.3316579759120941, .31548094749450684, .7781674265861511, -.2747528851032257, .07437903434038162, -.37279585003852844, .0519137866795063, -.2859345078468323, .07526100426912308, .1488046497106552, -.14232733845710754, .32971855998039246, .8421849608421326, -.41174718737602234, -.26829686760902405, .319733202457428, .26878175139427185, .033239174634218216],
      [-.2522253096103668, -.517288863658905, .5161744356155396, .23379305005073547, .5183485150337219, -.3354962170124054, -.2615361213684082, -.26796525716781616, -.2906893789768219, -.5899125337600708, -.24071922898292542, .19298170506954193, .2448270320892334, -.18195390701293945, .22872689366340637, -.03883763775229454, .11393126100301743, -.20769988000392914, .145860493183136, -.16606438159942627, -.21303708851337433, -.48039230704307556],
      [.2711339592933655, .14877256751060486, -.5210208892822266, -.0718262791633606, -.5058549642562866, -.19734041392803192, .35175836086273193, -.24450579285621643, .14651794731616974, -.3492460250854492, .05914080888032913, -.2946506440639496, .33659613132476807, -.20848320424556732, .22042110562324524, .026677392423152924, -.120904341340065, .6860695481300354, -.11122800409793854, -.3497786223888397, -.23798848688602448, -.04243595525622368],
      [-.0005888511659577489, -.09442724287509918, .5304970145225525, .4340223968029022, -.20511206984519958, .06684353202581406, .11319282650947571, -.045074108988046646, -.2944355010986328, -.1855180412530899, -.01609075628221035, -.2797134518623352, -.22387288510799408, -.11150441318750381, .2549881637096405, -.12239646911621094, .07021603733301163, -.11138070374727249, .30096933245658875, .2269570678472519, -.09848209470510483, .1337771713733673],
      [-.3409866988658905, .09799980372190475, .34216728806495667, -.11849728226661682, .3489639461040497, .03427177667617798, .019569091498851776, .27743619680404663, -.3783646523952484, .08194182068109512, .3159301280975342, -.3047831654548645, -.22344589233398438, .03001837246119976, -.17742876708507538, -.06475576013326645, .3604910969734192, .5056421756744385, -.5187709331512451, -.10201416164636612, .2995547354221344, .38972145318984985],
      [.15790526568889618, -.7042837738990784, -.21302777528762817, .16848227381706238, -.0011877208016812801, -.12080258131027222, .15305638313293457, -.06351857632398605, .24704083800315857, .1949336677789688, -.19203990697860718, .10208465903997421, -.14348776638507843, -.019817309454083443, .3578086793422699, -.06728693842887878, -.041219498962163925, .09261504560709, -.0008712316630408168, .6049289107322693, .09791583567857742, -.14355120062828064],
      [-.340536892414093, -.2713514268398285, .14431649446487427, -.15454277396202087, .10807453095912933, -.050114501267671585, .10406704992055893, -.5272601246833801, -.6372876763343811, -.3511631488800049, -.09119215607643127, .1876855343580246, -.052796024829149246, .24489940702915192, .313448429107666, -.09377001971006393, .5154397487640381, .09070395678281784, -.6212502717971802, .17910055816173553, .5232325792312622, .25079724192619324],
      [-.26155754923820496, -.12035878002643585, -.42760661244392395, .245542511343956, .10395646840333939, -.3039328455924988, .1414078176021576, -.08854835480451584, -.32020410895347595, -.28968074917793274, .1042105108499527, -.07309246063232422, .43100273609161377, -.2701120972633362, .2234169989824295, -.671525239944458, .288310170173645, -.2506396174430847, -.18530915677547455, .36756694316864014, .3223952054977417, .09720490872859955],
      [.0048901233822107315, .07265561819076538, -.35594671964645386, -.11603512614965439, -.15236087143421173, .14494124054908752, .1448768526315689, -.36369720101356506, -.014700887724757195, -.10618574917316437, -.3047960102558136, -.060007013380527496, .07276907563209534, -.2204989790916443, -.28425073623657227, .13357718288898468, .5236550569534302, .15444955229759216, .2488888055086136, .03437163308262825, -.23247507214546204, .005220160819590092],
      [.12635678052902222, .2643825113773346, .09618358314037323, .30235883593559265, .10851796716451645, -.12228379398584366, -.6704323291778564, -.3195283114910126, -.03379087522625923, .6435897350311279, .02658277563750744, -.21764814853668213, .18986494839191437, .1263182908296585, .30815866589546204, -.48451563715934753, -.02508516237139702, -.36718565225601196, .27426716685295105, .013748728670179844, -.1168714314699173, .2777203917503357],
      [-.05303778499364853, .23079954087734222, -.2526874244213104, .1471528857946396, -.22469462454319, .1619638353586197, .6265314817428589, -.24041402339935303, .2765970230102539, -.022972799837589264, .14581379294395447, .12737715244293213, -.022403568029403687, .05446542054414749, -.21993839740753174, .10859154164791107, -.10817687958478928, -.005141626112163067, .0020852137822657824, .23168736696243286, .20571266114711761, -.27596864104270935],
      [-.20376110076904297, -.23601752519607544, -.011796247214078903, .1612256020307541, .040002454072237015, .08589599281549454, -.04271416366100311, -.2430938184261322, -.20706722140312195, .5156735777854919, -1.029672384262085, .023737074807286263, -.1586734652519226, .11005079746246338, .4791591763496399, .07073191553354263, -.03587636351585388, -.6626523733139038, -.0992889255285263, -.2445378601551056, -.16236688196659088, .06376606971025467],
      [.09244076162576675, .1779661476612091, -.11597374081611633, .01695108413696289, .00949272233992815, -.292076975107193, -.24221444129943848, .32319143414497375, .17510345578193665, .09558748453855515, .12434366345405579, .17513149976730347, .31394994258880615, .12824398279190063, .1708582639694214, -.22496280074119568, .050107184797525406, .26826056838035583, -.23173128068447113, .0864020511507988, .149252250790596, .26481950283050537],
      [.18756704032421112, .18683187663555145, .168940007686615, -.1527096927165985, -.653537392616272, -.15870201587677002, .31289443373680115, -.09279714524745941, -.15902456641197205, -.17149129509925842, -.867825448513031, -.2728012502193451, .05206881836056709, .340526819229126, -.018828444182872772, -.028872216120362282, -.1294214427471161, -.03918104246258736, .09166116267442703, -.11092685908079147, .20878075063228607, .045484382659196854],
      [.12656863033771515, .09445389360189438, .2527928650379181, .24332231283187866, .0564589723944664, .009533763863146305, -.41191378235816956, -.06575063616037369, -.17768153548240662, -.17466725409030914, -.45918580889701843, .15444731712341309, -.2819361984729767, .34137675166130066, -.024160711094737053, .38564231991767883, .3331463634967804, -.28377628326416016, .5097813010215759, .2995654046535492, -.11779270321130753, .10989247262477875],
      [.6235911846160889, .5218830108642578, -.3642538785934448, -.01987980306148529, -.5573906898498535, .2346131056547165, -.20130567252635956, .0832921639084816, -.10051722824573517, .10714425891637802, .011679788120090961, -.27282148599624634, -.22900480031967163, .10947596281766891, .26548290252685547, -.8804737329483032, .0030504188034683466, .06604402512311935, -.27806901931762695, .15062768757343292, -.15133439004421234, .10839253664016724],
      [.38822513818740845, .20904885232448578, .08299731463193893, -.24808096885681152, .02364499308168888, -.14151637256145477, -.12024284899234772, .2132977396249771, .11459355801343918, -.01395323034375906, -.6034908294677734, .151336669921875, -.46442654728889465, .05114911496639252, .036679890006780624, -.20165006816387177, -.22427260875701904, -.4603407382965088, .5522147417068481, -.07961949706077576, -.3186766505241394, -.03414156287908554],
      [.31945154070854187, .5008490085601807, -.25702062249183655, .4540121555328369, -.3222987651824951, .14013437926769257, .1421363353729248, .23765110969543457, -.3621180057525635, -.31836825609207153, -.09170056879520416, .17745822668075562, .37772443890571594, -.4531503915786743, .44895139336586, -.14674697816371918, .4243408441543579, -.04294269531965256, .031283486634492874, -.5030778050422668, -.6654865741729736, -.04475428909063339]
    ]
  }
  static getDense1Biases() {
    return [.330281138420105, -.18092848360538483, .05752718448638916, -.1576835960149765, .022508956491947174, -.5283011198043823, .29089149832725525, .054204244166612625, .1237371414899826, -.04530307650566101, .09764876961708069, -.007767252158373594, -.5729328989982605, .5742050409317017, -.14500825107097626, .12060429900884628, .38622304797172546, -.017202207818627357, -.17475436627864838, .024721648544073105, .25638657808303833, -.11272697895765305]
  }
  static getDense2Weights() {
    return [
      [-.09530961513519287, .7137172818183899, -.09272975474596024, -.5992987751960754, -.19954442977905273, -.03901507332921028, .5740379691123962, -.46796706318855286, -.022164804860949516, -.13235603272914886],
      [.01685546524822712, -.17171968519687653, .8261204361915588, -.10724067687988281, -.7898566722869873, -.23153257369995117, -.42770829796791077, .251539021730423, -.7225059866905212, -1.3206950426101685],
      [.1561363935470581, -1.0501503944396973, -.6070868968963623, -.1366729736328125, .32089176774024963, .060511063784360886, .15824556350708008, -.19970576465129852, -.3158847987651825, .3512590229511261],
      [-.36580798029899597, -.10171006619930267, .23758672177791595, .2852209210395813, -.4753306806087494, .5637049674987793, -.15864413976669312, -.06867105513811111, -.23937013745307922, -1.050742745399475],
      [-.15432755649089813, -.3338127136230469, .3469362258911133, .09666202962398529, .0015601103659719229, .2211867719888687, -.7655377984046936, .6562585830688477, -.3501991331577301, .5780100226402283],
      [-.06021394580602646, .238181933760643, .5961139798164368, .07998987287282944, -.33442699909210205, -1.2791937589645386, -.875914990901947, -.039835043251514435, -.1346936672925949, .11976254731416702],
      [.2708156704902649, -.5357149839401245, .41104891896247864, -.6131432056427002, -.24247658252716064, .0042351423762738705, .6313011646270752, -.44320452213287354, .4103544354438782, -.23322540521621704],
      [-.7503973245620728, .5034997463226318, -.0603618361055851, -.06458444148302078, .5743234157562256, .26887422800064087, -.5349048376083374, .3218473196029663, .5688400268554688, .01841244101524353],
      [-.5596516728401184, -.25004926323890686, -.6157001852989197, -.199906587600708, -.11055586487054825, .2987595796585083, -.09301045536994934, -.03491904214024544, .21807578206062317, -.05601510405540466],
      [.013217143714427948, .06414958834648132, -.439352810382843, .304470419883728, .5281264781951904, .07186313718557358, -.9720727801322937, -.12304436415433884, -.39738601446151733, .4231846332550049],
      [-.24385316669940948, .6807219386100769, -.28166070580482483, -.6695762276649475, .6273496150970459, -.7192689180374146, -.20609520375728607, .12909340858459473, -.8274023532867432, .013556007295846939],
      [-.3839719593524933, -.17257535457611084, -.06756111979484558, .3495776355266571, -.39356398582458496, .3267740309238434, .01581544056534767, .19287236034870148, .3147165775299072, .2994825541973114],
      [-.1781357377767563, .38706812262535095, -.033865608274936676, -.04331136494874954, -.49919769167900085, -.16838164627552032, -1.267374038696289, .5873692631721497, -.49982157349586487, -.31088027358055115],
      [.5618163347244263, -.10148680210113525, -.39781925082206726, -.22547392547130585, -.7915878891944885, .29665371775627136, .2851561903953552, .05261880159378052, -.3141406178474426, -.07333453744649887],
      [-.42801979184150696, .15714558959007263, .22654478251934052, .2787051796913147, .09358803182840347, -.0552908293902874, .1480150818824768, -.39301449060440063, -.015354619361460209, .018854942172765732],
      [.5216989517211914, .5292819738388062, -.26467546820640564, -.30302149057388306, -.8634313941001892, .1078912541270256, .598487138748169, -.3910936415195465, .08454098552465439, .33176130056381226],
      [.13095960021018982, .531387984752655, .030621850863099098, -.375721275806427, .8001042604446411, -.4242725968360901, -.24359020590782166, .2622157037258148, -.5664139986038208, .2981870770454407],
      [.018946973606944084, -.13933154940605164, .2396472841501236, -.19645990431308746, -.31107664108276367, -.9731655120849609, .5193525552749634, .3321044445037842, .3325704038143158, -.06447841972112656],
      [-.10122614353895187, -.17986270785331726, -.3472631573677063, .3539492189884186, -.25638890266418457, -.08113092929124832, -.8919641375541687, -.2096220701932907, .41486015915870667, .15737999975681305],
      [-.04544200375676155, -.4476265609264374, .22150294482707977, .47791945934295654, .45305147767066956, .2017773687839508, .3117782771587372, .2902986407279968, .24421140551567078, -.5188177824020386],
      [.3439822494983673, .689713716506958, .3481121063232422, .076691634953022, -.1811024397611618, -.6353004574775696, .04896910488605499, .3020887076854706, -.2611197233200073, -.4551469087600708],
      [.15071196854114532, .7771721482276917, .20572848618030548, -.02264275588095188, -.6741758584976196, .6625444293022156, -.03247112035751343, .02812131680548191, -.03936261311173439, .013455331325531006]
    ]
  }
  static getDense2Biases() {
    return [-.05612999200820923, .09702792763710022, -.1935296207666397, -.27187228202819824, .09215883910655975, .13838817179203033, .41206279397010803, -.12245025485754013, .11650058627128601, -.16888585686683655]
  }
};
window.NetworkWeights = I;
let H = class {
  static denseLayer(e, t, i) {
    const s = e.length,
      o = i.length;
    if (t.length !== s) throw new Error(`Weight matrix input dimension ${t.length} doesn't match input size ${s}`);
    if (t[0].length !== o) throw new Error(`Weight matrix output dimension ${t[0].length} doesn't match bias size ${o}`);
    const n = new Array(o);
    for (let r = 0; r < o; r++) {
      let a = i[r];
      for (let l = 0; l < s; l++) a += e[l] * t[l][r];
      n[r] = a
    }
    return n
  }
  static relu(e) {
    return Math.max(0, e)
  }
  static applyReLU(e) {
    return e.map(t => this.relu(t))
  }
  static softmax(e) {
    const t = Math.max(...e),
      i = e.map(o => Math.exp(o - t)),
      s = i.reduce((o, n) => o + n, 0);
    return i.map(o => o / s)
  }
  static normalizeForVisualization(e) {
    const t = Math.min(...e),
      s = Math.max(...e) - t;
    return s === 0 ? e.map(() => .5) : e.map(o => (o - t) / s)
  }
  static getPredictedClass(e) {
    let t = -1,
      i = -1;
    for (let s = 0; s < e.length; s++) e[s] > t && (t = e[s], i = s);
    return {
      class: i,
      confidence: t
    }
  }
};
window.NeuralNetworkUtils = H;
class N {
  constructor() {
    this.scene = new THREE.Scene, this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, .1, 1e3), this.renderer = new THREE.WebGLRenderer({
      antialias: !0
    }), this.labelRenderer = new THREE.CSS2DRenderer, this.gridSize = 28, this.cubeCount = this.gridSize * this.gridSize, this.cubeStates = [], this.convolutionUtils = new ConvolutionUtils, this.grids = [], this.currentImage = null, this.denseConnections = null, this.connectionMeshes = [], this.calculationResults = {
      originalImage: null,
      firstConvolution: null,
      firstPooling: null,
      secondConvolutions: [],
      secondPoolings: [],
      flattenedVector: null,
      dense1Output: null,
      dense2Output: null
    }, this.init(), this.createGrids(), this.setupLighting(), this.setupControls(), this.animate()
  }
  init() {
    this.renderer.setSize(window.innerWidth, window.innerHeight), this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = THREE.PCFSoftShadowMap, this.renderer.setClearColor(657930), document.body.appendChild(this.renderer.domElement), this.labelRenderer.setSize(window.innerWidth, window.innerHeight), this.labelRenderer.domElement.style.position = "absolute", this.labelRenderer.domElement.style.top = "0px", this.labelRenderer.domElement.style.pointerEvents = "none", document.body.appendChild(this.labelRenderer.domElement), this.camera.position.set(27, 20, 6.5), this.camera.lookAt(0, 0, 0), window.addEventListener("resize", () => this.onWindowResize())
  }
  createGrids() {
    const e = new THREE.BoxGeometry(.8, .8, .8),
      t = [{
        x: 0,
        y: 32,
        z: 15
      }, {
        x: -10,
        y: 50,
        z: 0
      }, {
        x: -20,
        y: 50,
        z: -10
      }, {
        x: -10,
        y: 30,
        z: -30
      }, {
        x: -20,
        y: 35,
        z: -35
      }, {
        x: -25,
        y: 40,
        z: -40
      }, {
        x: -30,
        y: 45,
        z: -45
      }, {
        x: 15,
        y: 10,
        z: -20
      }, {
        x: 15,
        y: 10,
        z: -40
      }, {
        x: 15,
        y: 10,
        z: -60
      }, {
        x: -32,
        y: 48,
        z: -12
      }, {
        x: -37,
        y: 48,
        z: -30
      }],
      i = [28, 26, 13, 11, 11, 5, 5, 50, 22, 10, 3, 6];
    for (let s = 0; s < 12; s++) {
      const o = i[s];
      let n;
      s >= 7 && s <= 9 ? n = o : s === 10 ? n = 9 : s === 11 ? n = 18 : n = o * o;
      const r = new THREE.MeshLambertMaterial,
        a = new THREE.InstancedMesh(e, r, n),
        l = new Float32Array(n * 3),
        c = [],
        d = [],
        u = new THREE.Matrix4,
        h = new THREE.Color;
      let g = 0;
      if (s >= 7 && s <= 9)
        for (let m = 0; m < o; m++) {
          const f = t[s].x,
            w = t[s].y + (m - o / 2) * 1.2,
            b = t[s].z;
          u.setPosition(f, w, b), a.setMatrixAt(g, u), c.push({
            x: f,
            y: w,
            z: b
          }), h.setStyle("#2a2a2a"), l[g * 3] = h.r, l[g * 3 + 1] = h.g, l[g * 3 + 2] = h.b, a.setColorAt(g, h), d.push({
            state: "default",
            fadeStart: null
          }), g++
        } else if (s === 10)
          for (let f = 0; f < 3; f++)
            for (let w = 0; w < 3; w++) {
              const b = (f - 1) * 1.2 + t[s].x,
                p = (-w - 1) * 1.2 + t[s].y,
                C = t[s].z;
              u.setPosition(b, p, C), a.setMatrixAt(g, u), c.push({
                x: b,
                y: p,
                z: C
              });
              const E = this.convolutionUtils.filters[w][f][0][0],
                v = this.normalizeWeightForColor(E, this.convolutionUtils.filters),
                y = this.convolutionUtils.valueToColor(v);
              l[g * 3] = y.r, l[g * 3 + 1] = y.g, l[g * 3 + 2] = y.b, a.setColorAt(g, y), d.push({
                state: "default",
                fadeStart: null
              }), g++
            } else if (s === 11)
              for (let m = 0; m < 2; m++) {
                const f = m * 1.4,
                  w = 2 / 2;
                for (let b = 0; b < 3; b++)
                  for (let p = 0; p < 3; p++) {
                    const C = (b - w) * 1.2 + t[s].x,
                      E = (-p - w) * 1.2 + t[s].y,
                      v = t[s].z + f;
                    u.setPosition(C, E, v), a.setMatrixAt(g, u), c.push({
                      x: C,
                      y: E,
                      z: v
                    });
                    const y = this.convolutionUtils.filters2[p][b][0][m],
                      S = this.normalizeWeightForColor(y, this.convolutionUtils.filters2),
                      z = this.convolutionUtils.valueToColor(S);
                    l[g * 3] = z.r, l[g * 3 + 1] = z.g, l[g * 3 + 2] = z.b, a.setColorAt(g, z), d.push({
                      state: "default",
                      fadeStart: null
                    }), g++
                  }
              } else {
                const m = (o - 1) / 2;
                for (let f = 0; f < o; f++)
                  for (let w = 0; w < o; w++) {
                    const b = (f - m) * 1.2 + t[s].x,
                      p = (-w - m) * 1.2 + t[s].y,
                      C = t[s].z;
                    u.setPosition(b, p, C), a.setMatrixAt(g, u), c.push({
                      x: b,
                      y: p,
                      z: C
                    }), h.setStyle("#2a2a2a"), l[g * 3] = h.r, l[g * 3 + 1] = h.g, l[g * 3 + 2] = h.b, a.setColorAt(g, h), d.push({
                      state: "default",
                      fadeStart: null
                    }), g++
                  }
              }
      this.scene.add(a), this.grids.push({
        instancedMesh: a,
        cubeColors: l,
        cubePositions: c,
        cubeStates: d,
        gridSize: o
      })
    }
    this.createConvolutionBoundingBoxes(t, i), this.createDenseConnections(), this.instancedMesh = this.grids[0].instancedMesh, this.cubeColors = this.grids[0].cubeColors, this.cubePositions = this.grids[0].cubePositions, this.cubeStates = this.grids[0].cubeStates, this.axisHelper = new THREE.AxesHelper(10), this.scene.add(this.axisHelper)
  }
  normalizeWeightForColor(e, t) {
    const i = [];
    if (t === this.convolutionUtils.filters)
      for (let r = 0; r < t.length; r++)
        for (let a = 0; a < t[r].length; a++) i.push(t[r][a][0][0]);
    else if (t === this.convolutionUtils.filters2)
      for (let r = 0; r < t.length; r++)
        for (let a = 0; a < t[r].length; a++)
          for (let l = 0; l < 2; l++) i.push(t[r][a][0][l]);
    const s = Math.min(...i),
      n = Math.max(...i) - s;
    return n === 0 ? .5 : (e - s) / n
  }
  createConvolutionBoundingBoxes(e, t) {
    this.createBoundingBox(e, t, 1, 2, 16777215, `Convolution Layer 1
(3x3 filters → ReLU → MaxPool)`, "top-left"), this.createBoundingBox(e, t, 3, 6, 16777215, `Convolution Layer 2
(3x3 filters × 2 → ReLU → MaxPool)`, "top-front"), this.createBoundingBox(e, t, 7, 9, 16777215, "Dense Layers", "top-front")
  }
  createBoundingBox(e, t, i, s, o, n, r = "top-left") {
    const a = 1.6800000000000002;
    let l = 1 / 0,
      c = -1 / 0,
      d = 1 / 0,
      u = -1 / 0,
      h = 1 / 0,
      g = -1 / 0;
    for (let p = i; p <= s; p++) {
      const C = this.grids[p];
      if (!C) continue;
      C.cubePositions.forEach(v => {
        l = Math.min(l, v.x), c = Math.max(c, v.x), d = Math.min(d, v.y), u = Math.max(u, v.y), h = Math.min(h, v.z - .4), g = Math.max(g, v.z + .4)
      })
    }
    l -= a, c += a, d -= a, u += a, h -= a, g += a;
    const m = .02,
      f = new THREE.MeshBasicMaterial({
        color: o
      }),
      w = [{
        start: [l, d, h],
        end: [c, d, h]
      }, {
        start: [c, d, h],
        end: [c, u, h]
      }, {
        start: [c, u, h],
        end: [l, u, h]
      }, {
        start: [l, u, h],
        end: [l, d, h]
      }, {
        start: [l, d, g],
        end: [c, d, g]
      }, {
        start: [c, d, g],
        end: [c, u, g]
      }, {
        start: [c, u, g],
        end: [l, u, g]
      }, {
        start: [l, u, g],
        end: [l, d, g]
      }, {
        start: [l, d, h],
        end: [l, d, g]
      }, {
        start: [c, d, h],
        end: [c, d, g]
      }, {
        start: [c, u, h],
        end: [c, u, g]
      }, {
        start: [l, u, h],
        end: [l, u, g]
      }],
      b = new THREE.Group;
    if (w.forEach(p => {
        const C = new THREE.Vector3(...p.start),
          E = new THREE.Vector3(...p.end),
          v = C.distanceTo(E),
          y = new THREE.CylinderGeometry(m, m, v, 8),
          S = new THREE.Mesh(y, f),
          z = C.clone().add(E).multiplyScalar(.5);
        S.position.copy(z);
        const x = E.clone().sub(C).normalize();
        if (Math.abs(x.y) < .99) {
          const R = new THREE.Vector3(0, 1, 0),
            T = new THREE.Quaternion().setFromUnitVectors(R, x);
          S.setRotationFromQuaternion(T)
        }
        b.add(S)
      }), n) {
      const p = document.createElement("div");
      p.className = "annotation", p.style.whiteSpace = "pre-line", p.textContent = n;
      const C = new THREE.CSS2DObject(p);
      let E, v, y;
      switch (r) {
        case "top-left":
          E = l, v = u + 2.2, y = g;
          break;
        case "top-right":
          E = c, v = u + 2.2, y = g;
          break;
        case "bottom-left":
          E = l, v = d - 2.2, y = g;
          break;
        case "bottom-right":
          E = c, v = d - 2.2, y = g;
          break;
        case "top-front":
          E = l, v = u + 3.5, y = h;
          break;
        case "top-back":
          E = (l + c) / 2, v = u + 2.2, y = g;
          break;
        default:
          E = l, v = u + 2.2, y = g;
          break
      }
      C.position.set(E, v, y), b.add(C)
    }
    this.scene.add(b)
  }
  setupLighting() {
    const e = new THREE.AmbientLight(4210752, 5);
    this.scene.add(e), this.spotlight1 = new THREE.SpotLight(16777215, 2), this.spotlight1.position.set(30, 30, 40), this.spotlight1.angle = Math.PI / 9, this.spotlight1.penumbra = .3, this.spotlight1.decay = 0, this.spotlight1.distance = 50, this.spotlight1.castShadow = !0, this.spotlight1.shadow.mapSize.width = 2048, this.spotlight1.shadow.mapSize.height = 2048, this.scene.add(this.spotlight1), this.spotlight2 = new THREE.SpotLight(16777215, 3), this.spotlight2.position.set(30, 30, -60), this.spotlight2.angle = Math.PI / 4, this.spotlight2.penumbra = .3, this.spotlight2.decay = 0, this.spotlight2.distance = 50, this.spotlight2.castShadow = !0, this.spotlight2.shadow.mapSize.width = 2048, this.spotlight2.shadow.mapSize.height = 2048, this.scene.add(this.spotlight2)
  }
  setupControls() {
    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement), this.controls.enableDamping = !0, this.controls.dampingFactor = .05, this.controls.screenSpacePanning = !1, this.controls.minDistance = 10, this.controls.maxDistance = 100, this.controls.maxPolarAngle = Math.PI, this.controls.target.set(0, 0, 0), this.controls.autoRotate = !1, this.controls.autoRotateSpeed = .5
  }
  setCubeColor(e, t, i, s = 0) {
    if (s < this.grids.length) {
      const o = this.grids[s],
        n = o.gridSize;
      if (s >= 7) {
        if (e >= 0 && e < n) {
          const r = e,
            a = i instanceof THREE.Color ? i : new THREE.Color(i);
          o.cubeColors[r * 3] = a.r, o.cubeColors[r * 3 + 1] = a.g, o.cubeColors[r * 3 + 2] = a.b, o.instancedMesh.setColorAt(r, a), o.instancedMesh.instanceColor.needsUpdate = !0
        }
      } else if (e >= 0 && e < n && t >= 0 && t < n) {
        const r = e * n + t,
          a = i instanceof THREE.Color ? i : new THREE.Color(i);
        o.cubeColors[r * 3] = a.r, o.cubeColors[r * 3 + 1] = a.g, o.cubeColors[r * 3 + 2] = a.b, o.instancedMesh.setColorAt(r, a), o.instancedMesh.instanceColor.needsUpdate = !0
      }
    }
  }
  setCubeState(e, t, i, s = 0) {
    if (s < this.grids.length) {
      const o = this.grids[s],
        n = o.gridSize;
      if (s >= 7) {
        if (e >= 0 && e < n) {
          const r = e;
          o.cubeStates[r].state = i
        }
      } else if (e >= 0 && e < n && t >= 0 && t < n) {
        const r = e * n + t;
        o.cubeStates[r].state = i
      }
    }
  }
  updateImageWithConvolutions(e) {
    this.currentImage = e, this.calculationResults.originalImage = e, this.updateGridFromImage(e, 0);
    const t = [];
    try {
      const s = this.convolutionUtils.applyConvolution(e, 0),
        o = this.convolutionUtils.applyReLUActivation(s);
      this.calculationResults.firstConvolution = o;
      const n = this.convolutionUtils.normalizeForColor(o);
      this.updateGridFromNormalizedData(n, 1);
      const r = this.convolutionUtils.applyMaxPooling(o, 2);
      this.calculationResults.firstPooling = r;
      const a = this.convolutionUtils.normalizeForColor(r);
      this.updateGridFromNormalizedData(a, 2), t.push(r)
    } catch (s) {
      console.error("Error applying first convolution/pooling:", s)
    }
    const i = [];
    if (t.length === 1)
      for (let s = 0; s < 2; s++) try {
        const o = this.convolutionUtils.applyConvolution2(t, s),
          n = this.convolutionUtils.applyReLUActivation(o);
        this.calculationResults.secondConvolutions[s] = n;
        const r = this.convolutionUtils.normalizeForColor(n);
        this.updateGridFromNormalizedData(r, s + 3);
        const a = this.convolutionUtils.applyMaxPooling(n, 2);
        this.calculationResults.secondPoolings[s] = a;
        const l = this.convolutionUtils.normalizeForColor(a);
        this.updateGridFromNormalizedData(l, s + 5), i.push(a)
      } catch (o) {
        console.error(`Error applying second convolution/pooling ${s}:`, o)
      }
    this.updateFlattenedVector(i)
  }
  updateGridFromImage(e, t) {
    for (let i = 0; i < this.gridSize; i++)
      for (let s = 0; s < this.gridSize; s++)
        if (e[i] && e[i][s] !== void 0) {
          const o = Array.isArray(e[i][s]) ? e[i][s][0] : e[i][s],
            n = Math.max(0, Math.min(1, o)),
            r = new THREE.Color(n, n, n);
          this.setCubeColor(s, i, r, t);
          const a = this.grids[t],
            l = s * a.gridSize + i;
          a.userData || (a.userData = {}), a.userData.values || (a.userData.values = {}), a.userData.values[l] = n
        }
  }
  updateGridFromNormalizedData(e, t) {
    const i = this.grids[t],
      s = i.gridSize,
      o = e.length,
      n = e[0].length;
    for (let r = 0; r < Math.min(s, o); r++)
      for (let a = 0; a < Math.min(s, n); a++)
        if (e[r] && e[r][a] !== void 0) {
          const l = this.convolutionUtils.valueToColor(e[r][a]);
          this.setCubeColor(a, r, l, t);
          const c = a * s + r;
          i.userData || (i.userData = {}), i.userData.values || (i.userData.values = {}), i.userData.values[c] = e[r][a]
        }
  }
  updateFlattenedVector(e) {
    if (e.length !== 2) return;
    let t = 0;
    const i = [];
    for (let s = 0; s < e[0].length; s++)
      for (let o = 0; o < e[0][s].length; o++)
        for (let n = 0; n < 2; n++)
          if (t < 50) {
            const a = e[n][s][o];
            i.push(a);
            const l = [];
            e.forEach(m => {
              m.forEach(f => {
                f.forEach(w => l.push(w))
              })
            });
            const c = Math.min(...l),
              u = Math.max(...l) - c,
              h = u === 0 ? .5 : (a - c) / u,
              g = this.convolutionUtils.valueToColor(h);
            this.setCubeColor(t, 0, g, 7), t++
          } this.updateDenseLayers(i)
  }
  updateDenseLayers(e) {
    this.calculationResults.flattenedVector = [...e];
    const t = new Array(50).fill(0);
    for (let h = 0; h < Math.min(e.length, 50); h++) t[h] = e[h];
    const i = NetworkWeights.getDense1Weights(),
      s = NetworkWeights.getDense1Biases(),
      o = NeuralNetworkUtils.denseLayer(t, i, s),
      n = NeuralNetworkUtils.applyReLU(o),
      r = NeuralNetworkUtils.normalizeForVisualization(n);
    for (let h = 0; h < 22; h++) {
      const g = r[h],
        m = this.convolutionUtils.valueToColor(g);
      this.setCubeColor(h, 0, m, 8);
      const f = this.grids[8];
      f.userData || (f.userData = {}), f.userData.values || (f.userData.values = {}), f.userData.values[h] = n[h], f.userData.normalizedValues || (f.userData.normalizedValues = {}), f.userData.normalizedValues[h] = g
    }
    this.calculationResults.dense1Output = [...n];
    const a = NetworkWeights.getDense2Weights(),
      l = NetworkWeights.getDense2Biases(),
      c = NeuralNetworkUtils.denseLayer(n, a, l),
      d = NeuralNetworkUtils.softmax(c);
    for (let h = 0; h < 10; h++) {
      const g = d[h],
        m = this.convolutionUtils.valueToColor(g);
      this.setCubeColor(h, 0, m, 9);
      const f = this.grids[9];
      f.userData || (f.userData = {}), f.userData.values || (f.userData.values = {}), f.userData.values[h] = g
    }
    this.calculationResults.dense2Output = [...d];
    const u = NeuralNetworkUtils.getPredictedClass(d);
    console.log(`Predicted class: ${u.class} with confidence: ${(u.confidence*100).toFixed(2)}%`), this.updatePredictionChart(d, u), this.updateConnectionVisualizations()
  }
  updatePredictionChart(e, t) {
    const i = new CustomEvent("predictionUpdate", {
      detail: {
        probabilities: e,
        prediction: t
      }
    });
    window.dispatchEvent(i)
  }
  updateConnectionVisualizations() {
    if (this.connectionMeshes.length >= 2) {
      const e = this.calculationResults.flattenedVector || new Array(50).fill(0),
        t = this.calculationResults.dense1Output || new Array(22).fill(0),
        i = this.calculationResults.dense2Output || new Array(10).fill(0);
      this.denseConnections.updateConnectionOpacity(this.connectionMeshes[0], .5), this.denseConnections.updateConnectionActivations(this.connectionMeshes[0], e, t, .05), this.denseConnections.updateConnectionOpacity(this.connectionMeshes[1], .5), this.denseConnections.updateConnectionActivations(this.connectionMeshes[1], t, i, .05)
    }
  }
  animate() {
    requestAnimationFrame(() => this.animate()), this.controls.update(), performance.now();
    const e = new THREE.Matrix4;
    for (let t = 0; t < this.grids.length; t++) {
      const i = this.grids[t],
        s = i.gridSize,
        o = t >= 7 && t <= 9,
        n = t >= 10;
      if (o)
        for (let r = 0; r < s; r++) {
          const a = r,
            l = i.cubeStates[a];
          let c = 1,
            d = 1;
          switch (l.state) {
            case "painted":
              c = 1.45, d = 1;
              break;
            case "hover":
              c = 1.3, d = 1;
              break;
            case "hover-neighbor":
              c = 1.15, d = 1;
              break;
            case "fade":
              c = 1.1, d = 1;
              break;
            default:
              c = 1, d = 1;
              break
          }
          const u = i.cubePositions[a];
          e.makeScale(c, c, c), e.setPosition(u.x, u.y, u.z), i.instancedMesh.setMatrixAt(a, e), i.instancedMesh.material.transparent = d < 1, i.instancedMesh.material.opacity = d
        } else {
          const r = n ? i.cubePositions.length : s * s;
          for (let a = 0; a < r; a++) {
            const l = i.cubeStates[a];
            let c = 1,
              d = 1;
            switch (l.state) {
              case "painted":
                c = n ? 1.2 : 1.5, d = 1;
                break;
              case "hover":
                c = n ? 1.4 : 3, d = 1;
                break;
              case "hover-neighbor":
                c = n ? 1.3 : 2.5, d = 1;
                break;
              case "fade":
                c = n ? 1.25 : 2.3, d = 1;
                break;
              default:
                c = 1, d = 1;
                break
            }
            const u = i.cubePositions[a];
            e.makeScale(c, c, c), e.setPosition(u.x, u.y, u.z), i.instancedMesh.setMatrixAt(a, e), i.instancedMesh.material.transparent = d < 1, i.instancedMesh.material.opacity = d
          }
        }
      i.instancedMesh.instanceMatrix.needsUpdate = !0
    }
    this.renderer.render(this.scene, this.camera), this.labelRenderer.render(this.scene, this.camera)
  }
  onWindowResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(window.innerWidth, window.innerHeight), this.labelRenderer.setSize(window.innerWidth, window.innerHeight)
  }
  toggleAutoRotate() {
    this.controls.autoRotate = !this.controls.autoRotate
  }
  setAutoRotateSpeed(e) {
    this.controls.autoRotateSpeed = e
  }
  createDenseConnections() {
    this.denseConnections = new DenseLayerConnections(this.scene);
    const e = NetworkWeights.getDense1Weights(),
      t = NetworkWeights.getDense2Weights();
    if (this.grids.length > 8) {
      const i = this.grids[7].cubePositions,
        s = this.grids[8].cubePositions,
        o = this.denseConnections.createConnections(i, s, e, "full");
      this.connectionMeshes.push(o)
    }
    if (this.grids.length > 9) {
      const i = this.grids[8].cubePositions,
        s = this.grids[9].cubePositions,
        o = this.denseConnections.createConnections(i, s, t, "full");
      this.connectionMeshes.push(o)
    }
  }
  getCalculationResults() {
    return this.calculationResults
  }
  resetDenseConnectionColors() {
    this.connectionMeshes && this.connectionMeshes.length > 0 && this.connectionMeshes.forEach(e => {
      if (e) {
        const t = e.count;
        for (let i = 0; i < t; i++) e.setColorAt(i, new THREE.Color(.1, .1, .1));
        e.instanceColor.needsUpdate = !0
      }
    })
  }
}
const k = new N;
window.cubeGrid = k;
window.THREE = THREE;
window.addEventListener("clear", () => {
  window.cubeGrid && window.cubeGrid.resetDenseConnectionColors()
});
class W {
  constructor() {
    this.gridSize = 28, this.displayGridSize = 22, this.gridOffset = 3, this.brushSize = 1, this.isDragging = !1, this.paintedCells = new Map, this.currentHoverCell = null, this.visitedCells = new Set, this.fadeTimeouts = new Map, this.lastPaintedIndex = null, this.colors = {
      default: new window.THREE.Color(.16, .16, .16),
      hover: new window.THREE.Color(.5, .5, .8),
      hoverNeighbor: new window.THREE.Color(.3, .3, .6),
      painted: new window.THREE.Color(1, 1, 1),
      paintedLight: new window.THREE.Color(.7, .7, .7),
      paintedLighter: new window.THREE.Color(.4, .4, .4),
      visited: new window.THREE.Color(.6, .3, .9),
      fade: new window.THREE.Color(.3, .15, .45)
    }, this.brushOpacity = .6, this.initializeElements(), this.createGrid(), this.attachEventListeners()
  }
  initializeElements() {
    this.gridContainer = document.getElementById("gridContainer"), this.resetBtn = document.getElementById("resetBtn"), this.saveBtn = document.getElementById("saveBtn")
  }
  createGrid() {
    this.gridContainer.innerHTML = "";
    const e = document.createElement("div");
    e.className = "grid", e.style.gridTemplateColumns = `repeat(${this.displayGridSize}, 1fr)`, e.style.gridTemplateRows = `repeat(${this.displayGridSize}, 1fr)`;
    const i = window.innerWidth <= 1024 ? Math.min(window.innerWidth * .55, 300) : Math.min(400, window.innerWidth * .85),
      s = Math.floor(i / this.displayGridSize) - 1;
    e.style.width = `${i}px`, e.style.height = `${i}px`;
    for (let o = 0; o < this.displayGridSize * this.displayGridSize; o++) {
      const n = document.createElement("div");
      n.className = "grid-cell", n.style.width = `${s}px`, n.style.height = `${s}px`, n.dataset.index = o, this.attachCellEventListeners(n), e.appendChild(n)
    }
    this.gridContainer.appendChild(e), this.grid = e, this.grid.addEventListener("mouseleave", () => {
      this.isDragging = !1, this.lastPaintedIndex = null, this._mouseMovePaint && this.grid.removeEventListener("mousemove", this._mouseMovePaint)
    }), this.grid.addEventListener("touchcancel", () => {
      this.isDragging = !1, this.lastPaintedIndex = null, this._touchMovePaint && this.grid.removeEventListener("touchmove", this._touchMovePaint)
    })
  }
  attachCellEventListeners(e) {
    e.addEventListener("mouseenter", t => this.handleCellHover(t)), e.addEventListener("mouseleave", t => this.handleCellLeave(t)), e.addEventListener("mousedown", t => this.handleMouseDown(t)), e.addEventListener("mouseup", t => this.handleMouseUp(t)), e.addEventListener("mouseover", t => this.handleMouseOver(t)), e.addEventListener("contextmenu", t => t.preventDefault()), e.addEventListener("touchstart", t => this.handleTouchStart(t)), e.addEventListener("touchend", t => this.handleTouchEnd(t)), e.addEventListener("touchmove", t => this.handleTouchMove(t))
  }
  attachEventListeners() {
    this.resetBtn.addEventListener("click", () => this.reset()), this.saveBtn.addEventListener("click", () => this.saveMatrices()), document.addEventListener("mouseup", () => {
      this.isDragging = !1, this.lastPaintedIndex = null, this._mouseMovePaint && this.grid && this.grid.removeEventListener("mousemove", this._mouseMovePaint)
    }), document.addEventListener("touchend", () => {
      this.isDragging = !1, this.lastPaintedIndex = null, this._touchMovePaint && this.grid && this.grid.removeEventListener("touchmove", this._touchMovePaint)
    }), document.addEventListener("selectstart", e => {
      this.isDragging && e.preventDefault()
    })
  }
  displayToProcessingCoords(e) {
    const t = Math.floor(e / this.displayGridSize),
      i = e % this.displayGridSize,
      s = t + this.gridOffset,
      o = i + this.gridOffset;
    return s * this.gridSize + o
  }
  processingToDisplayCoords(e) {
    const t = Math.floor(e / this.gridSize),
      i = e % this.gridSize,
      s = t - this.gridOffset,
      o = i - this.gridOffset;
    return s < 0 || s >= this.displayGridSize || o < 0 || o >= this.displayGridSize ? -1 : s * this.displayGridSize + o
  }
  getDistance(e, t) {
    const i = Math.floor(e / this.displayGridSize),
      s = e % this.displayGridSize,
      o = Math.floor(t / this.displayGridSize),
      n = t % this.displayGridSize;
    return Math.sqrt(Math.pow(o - i, 2) + Math.pow(n - s, 2))
  }
  getNeighborsWithDistance(e, t = 3) {
    const i = [],
      s = Math.floor(e / this.displayGridSize),
      o = e % this.displayGridSize;
    for (let n = -t; n <= t; n++)
      for (let r = -t; r <= t; r++) {
        if (n === 0 && r === 0) continue;
        const a = s + n,
          l = o + r;
        if (a >= 0 && a < this.displayGridSize && l >= 0 && l < this.displayGridSize) {
          const c = a * this.displayGridSize + l,
            d = Math.sqrt(n * n + r * r);
          i.push({
            index: c,
            distance: d
          })
        }
      }
    return i
  }
  getBrushCells(e, t) {
    const i = [],
      s = Math.floor(e / this.displayGridSize),
      o = e % this.displayGridSize,
      n = t,
      r = Math.max(.001, n * .75);
    for (let a = -n; a <= n; a++)
      for (let l = -n; l <= n; l++) {
        const c = s + a,
          d = o + l;
        if (c >= 0 && c < this.displayGridSize && d >= 0 && d < this.displayGridSize) {
          const u = c * this.displayGridSize + d,
            h = a * a + l * l;
          if (Math.sqrt(h) <= n) {
            let g = Math.exp(-h / (2 * r * r));
            g = Math.min(1, Math.max(0, g + (Math.random() - .5) * .03)), i.push({
              index: u,
              intensity: g
            })
          }
        }
      }
    return i
  }
  getInterpolatedCells(e, t) {
    if (e === t) return [t];
    const i = Math.floor(e / this.displayGridSize),
      s = e % this.displayGridSize,
      o = Math.floor(t / this.displayGridSize),
      n = t % this.displayGridSize,
      r = [],
      a = Math.max(Math.abs(o - i), Math.abs(n - s));
    for (let l = 0; l <= a; l++) {
      const c = a === 0 ? 0 : l / a,
        d = Math.round(i + (o - i) * c),
        u = Math.round(s + (n - s) * c),
        h = d * this.displayGridSize + u;
      r.includes(h) || r.push(h)
    }
    return r
  }
  clearHoverEffects() {
    this.grid.querySelectorAll(".grid-cell").forEach(t => {
      t.classList.remove("hover-intensity-1", "hover-intensity-2", "hover-intensity-3")
    })
  }
  getNeighborIndices(e) {
    const t = [],
      i = Math.floor(e / this.displayGridSize),
      s = e % this.displayGridSize;
    for (let o = -1; o <= 1; o++)
      for (let n = -1; n <= 1; n++) {
        if (o === 0 && n === 0) continue;
        const r = i + o,
          a = s + n;
        if (r >= 0 && r < this.displayGridSize && a >= 0 && a < this.displayGridSize) {
          const l = r * this.displayGridSize + a;
          t.push(l)
        }
      }
    return t
  }
  getRandomNeighbors(e) {
    const t = this.getNeighborIndices(e),
      i = Math.floor(Math.random() * t.length) + 1;
    return [...t].sort(() => Math.random() - .5).slice(0, i)
  }
  handleCellHover(e) {
    if (this.isDragging) return;
    const t = parseInt(e.target.dataset.index),
      i = this.displayToProcessingCoords(t);
    if (this.currentHoverCell = t, !this.paintedCells.has(i)) {
      if (e.target.classList.add("hover"), window.cubeGrid) {
        const o = Math.floor(i / this.gridSize),
          n = i % this.gridSize;
        o < window.cubeGrid.gridSize && n < window.cubeGrid.gridSize && (window.cubeGrid.setCubeColor(n, o, this.colors.hover), window.cubeGrid.setCubeState(n, o, "hover"))
      }
      if (this.getRandomNeighbors(t).forEach(o => {
          const n = this.grid.children[o],
            r = this.displayToProcessingCoords(o);
          if (n && !this.paintedCells.has(r) && (n.classList.add("hover-neighbor"), window.cubeGrid)) {
            const a = Math.floor(r / this.gridSize),
              l = r % this.gridSize;
            a < window.cubeGrid.gridSize && l < window.cubeGrid.gridSize && !this.paintedCells.has(r) && (window.cubeGrid.setCubeColor(l, a, this.colors.hoverNeighbor), window.cubeGrid.setCubeState(l, a, "hover-neighbor"))
          }
        }), !this.visitedCells.has(t)) {
        this.visitedCells.add(t), e.target.classList.add("visited"), this.fadeTimeouts.has(t) && clearTimeout(this.fadeTimeouts.get(t));
        const o = Math.floor(Math.random() * 201) + 100,
          n = setTimeout(() => {
            if (e.target.classList.add("visited-fade"), e.target.classList.remove("visited"), window.cubeGrid && !this.paintedCells.has(i)) {
              const r = Math.floor(i / this.gridSize),
                a = i % this.gridSize;
              r < window.cubeGrid.gridSize && a < window.cubeGrid.gridSize && (window.cubeGrid.setCubeColor(a, r, this.colors.fade), window.cubeGrid.setCubeState(a, r, "fade"))
            }
            setTimeout(() => {
              if (e.target.classList.remove("visited-fade"), window.cubeGrid && !this.paintedCells.has(i)) {
                const r = Math.floor(i / this.gridSize),
                  a = i % this.gridSize;
                r < window.cubeGrid.gridSize && a < window.cubeGrid.gridSize && (window.cubeGrid.setCubeColor(a, r, this.colors.default), window.cubeGrid.setCubeState(a, r, "default"))
              }
            }, 2e3), this.visitedCells.delete(t), this.fadeTimeouts.delete(t)
          }, o);
        this.fadeTimeouts.set(t, n)
      }
    }
  }
  handleCellLeave(e) {
    if (this.isDragging) return;
    const t = parseInt(e.target.dataset.index),
      i = this.displayToProcessingCoords(t);
    if (e.target.classList.remove("hover"), window.cubeGrid && !this.paintedCells.has(i) && !this.visitedCells.has(t)) {
      const o = Math.floor(i / this.gridSize),
        n = i % this.gridSize;
      o < window.cubeGrid.gridSize && n < window.cubeGrid.gridSize && (window.cubeGrid.setCubeColor(n, o, this.colors.default), window.cubeGrid.setCubeState(n, o, "default"))
    }
    this.getNeighborIndices(t).forEach(o => {
      const n = this.grid.children[o],
        r = this.displayToProcessingCoords(o);
      if (n && (n.classList.remove("hover-neighbor"), window.cubeGrid && !this.paintedCells.has(r) && !this.visitedCells.has(o))) {
        const a = Math.floor(r / this.gridSize),
          l = r % this.gridSize;
        a < window.cubeGrid.gridSize && l < window.cubeGrid.gridSize && (window.cubeGrid.setCubeColor(l, a, this.colors.default), window.cubeGrid.setCubeState(l, a, "default"))
      }
    }), this.currentHoverCell = null
  }
  handleMouseDown(e) {
    e.preventDefault(), this.isDragging = !0;
    const t = parseInt(e.target.dataset.index);
    this.paintCells(t), this.lastPaintedIndex = t, this._mouseMovePaint = i => {
      const s = i.target;
      if (s.classList.contains("grid-cell")) {
        const o = parseInt(s.dataset.index);
        this.paintCellsWithInterpolation(o)
      }
    }, this.grid.addEventListener("mousemove", this._mouseMovePaint)
  }
  handleMouseUp(e) {
    this.isDragging = !1, this.lastPaintedIndex = null, this.grid.removeEventListener("mousemove", this._mouseMovePaint)
  }
  handleMouseOver(e) {
    if (this.isDragging) {
      const t = parseInt(e.target.dataset.index);
      this.paintCellsWithInterpolation(t)
    }
  }
  handleTouchStart(e) {
    e.preventDefault(), this.isDragging = !0;
    const t = e.touches[0],
      i = document.elementFromPoint(t.clientX, t.clientY);
    if (i && i.classList.contains("grid-cell")) {
      const s = parseInt(i.dataset.index);
      this.paintCells(s), this.lastPaintedIndex = s, this._touchMovePaint = o => {
        o.preventDefault();
        const n = o.touches[0],
          r = document.elementFromPoint(n.clientX, n.clientY);
        if (r && r.classList.contains("grid-cell")) {
          const a = parseInt(r.dataset.index);
          this.paintCellsWithInterpolation(a)
        }
      }, this.grid.addEventListener("touchmove", this._touchMovePaint, {
        passive: !1
      })
    }
  }
  handleTouchEnd(e) {
    e.preventDefault(), this.isDragging = !1, this.lastPaintedIndex = null, this._touchMovePaint && this.grid && this.grid.removeEventListener("touchmove", this._touchMovePaint)
  }
  handleTouchMove(e) {
    if (this.isDragging) {
      e.preventDefault();
      const t = e.touches[0],
        i = document.elementFromPoint(t.clientX, t.clientY);
      if (i && i.classList.contains("grid-cell")) {
        const s = parseInt(i.dataset.index);
        this.paintCellsWithInterpolation(s)
      }
    }
  }
  paintCellsWithInterpolation(e = null) {
    e !== null && (this.lastPaintedIndex !== null && this.lastPaintedIndex !== e ? this.getInterpolatedCells(this.lastPaintedIndex, e).forEach(i => {
      this.paintCells(i)
    }) : this.paintCells(e), this.lastPaintedIndex = e)
  }
  paintCells(e) {
    this.getBrushCells(e, this.brushSize).forEach(({
      index: i,
      intensity: s
    }) => {
      const o = this.displayToProcessingCoords(i),
        n = this.paintedCells.get(o) || 0,
        r = this.brushOpacity,
        a = 1 - (1 - n) * (1 - s * r),
        l = Math.min(1, Math.max(0, a));
      this.paintedCells.set(o, l);
      const c = this.grid.children[i];
      c.classList.remove("hover-intensity-1", "hover-intensity-2", "hover-intensity-3");
      let d;
      if (l > .85 ? (c.classList.add("painted"), c.classList.remove("painted-light", "painted-lighter"), d = this.colors.painted) : l > .2 ? (c.classList.add("painted-light"), c.classList.remove("painted", "painted-lighter"), d = this.colors.paintedLight) : l > .1 && (c.classList.add("painted-lighter"), c.classList.remove("painted", "painted-light"), d = this.colors.paintedLighter), window.cubeGrid && d) {
        const u = Math.floor(o / this.gridSize),
          h = o % this.gridSize;
        u < window.cubeGrid.gridSize && h < window.cubeGrid.gridSize && (window.cubeGrid.setCubeColor(h, u, d), window.cubeGrid.setCubeState(h, u, "painted"))
      }
    }), this.updateConvolutions()
  }
  updateConvolutions() {
    if (!window.cubeGrid) return;
    const e = [];
    for (let t = 0; t < this.gridSize; t++) {
      e[t] = [];
      for (let i = 0; i < this.gridSize; i++) {
        const s = t * this.gridSize + i,
          o = this.paintedCells.get(s) || 0;
        e[t][i] = o
      }
    }
    window.cubeGrid.updateImageWithConvolutions(e)
  }
  getMatrixValue(e, t, i) {
    if (Array.isArray(e)) return e[i] && e[i][t] !== void 0 ? e[i][t] : 0;
    {
      const s = i * this.gridSize + t;
      return e.get(s) || 0
    }
  }
  saveMatrices() {
    if (!window.cubeGrid) {
      alert("3D visualization not ready");
      return
    }
    const e = [];
    for (let r = 0; r < this.gridSize; r++) {
      e[r] = [];
      for (let a = 0; a < this.gridSize; a++) {
        const l = r * this.gridSize + a,
          c = this.paintedCells.get(l) || 0;
        e[r][a] = c
      }
    }
    const t = window.cubeGrid.getCalculationResults(),
      i = {
        timestamp: new Date().toISOString(),
        gridSize: this.gridSize,
        brushSize: this.brushSize,
        input: {
          matrix: e,
          dimensions: [this.gridSize, this.gridSize],
          description: "Original Input Drawing"
        },
        layers: []
      };
    t.originalImage && i.layers.push({
      index: 0,
      matrix: t.originalImage,
      dimensions: [t.originalImage.length, t.originalImage[0].length],
      description: "Network Input",
      isLinear: !1
    }), t.firstConvolution && i.layers.push({
      index: 1,
      matrix: t.firstConvolution,
      dimensions: [t.firstConvolution.length, t.firstConvolution[0].length],
      description: "Convolution 1 output",
      isLinear: !1
    }), t.firstPooling && i.layers.push({
      index: 2,
      matrix: t.firstPooling,
      dimensions: [t.firstPooling.length, t.firstPooling[0].length],
      description: "Max pooling 1 output",
      isLinear: !1
    }), t.secondConvolutions.forEach((r, a) => {
      r && i.layers.push({
        index: 3 + a,
        matrix: r,
        dimensions: [r.length, r[0].length],
        description: `Convolution 2 output (channel ${a+1})`,
        isLinear: !1
      })
    }), t.secondPoolings.forEach((r, a) => {
      r && i.layers.push({
        index: 5 + a,
        matrix: r,
        dimensions: [r.length, r[0].length],
        description: `Max pooling 2 output (channel ${a+1})`,
        isLinear: !1
      })
    }), t.flattenedVector && i.layers.push({
      index: 7,
      matrix: t.flattenedVector,
      dimensions: [t.flattenedVector.length],
      description: "Flattened vector",
      isLinear: !0
    }), t.dense1Output && i.layers.push({
      index: 8,
      matrix: t.dense1Output,
      dimensions: [t.dense1Output.length],
      description: "Dense layer 1 (22 neurons)",
      isLinear: !0
    }), t.dense2Output && i.layers.push({
      index: 9,
      matrix: t.dense2Output,
      dimensions: [t.dense2Output.length],
      description: "Dense layer 2 (10 neurons - output)",
      isLinear: !0
    });
    const s = JSON.stringify(i, null, 2),
      o = new Blob([s], {
        type: "application/json"
      }),
      n = document.createElement("a");
    n.href = URL.createObjectURL(o), n.download = `cnn_visualization_${new Date().toISOString().slice(0,19).replace(/:/g,"-")}.json`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(n.href)
  }
  reset() {
    if (this.paintedCells.clear(), this.visitedCells.clear(), this.lastPaintedIndex = null, this.fadeTimeouts.forEach(t => clearTimeout(t)), this.fadeTimeouts.clear(), this.grid.querySelectorAll(".grid-cell").forEach(t => {
        t.classList.remove("painted", "painted-light", "painted-lighter", "hover", "hover-neighbor", "visited", "visited-fade")
      }), window.cubeGrid) {
      for (let t = 0; t < 10; t++) {
        const s = window.cubeGrid.grids[t].gridSize;
        if (t >= 7)
          for (let n = 0; n < s; n++) window.cubeGrid.setCubeColor(n, 0, this.colors.default, t), window.cubeGrid.setCubeState(n, 0, "default", t);
        else
          for (let n = 0; n < s; n++)
            for (let r = 0; r < s; r++) window.cubeGrid.setCubeColor(n, r, this.colors.default, t), window.cubeGrid.setCubeState(n, r, "default", t)
      }
      for (let t = 10; t < window.cubeGrid.grids.length; t++) {
        const s = window.cubeGrid.grids[t].cubePositions.length;
        for (let o = 0; o < s; o++) window.cubeGrid.setCubeState(o, 0, "default", t)
      }
    }
    window.cubeGrid && typeof window.cubeGrid.resetDenseConnectionColors == "function" && window.cubeGrid.resetDenseConnectionColors(), G()
  }
}

function L() {
  window.cubeGrid && window.THREE ? new W : setTimeout(L, 50)
}
document.addEventListener("DOMContentLoaded", L);

function G() {
  const M = document.getElementById("predictionChart"),
    e = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
  M.innerHTML = "", e.forEach((t, i) => {
    const s = document.createElement("div");
    s.className = "prediction-bar-container", s.setAttribute("data-digit", i);
    const o = document.createElement("div");
    o.className = "prediction-label", o.textContent = t;
    const n = document.createElement("div");
    n.className = "prediction-bar-track";
    const r = document.createElement("div");
    r.className = "prediction-bar", r.style.width = "0%";
    const a = document.createElement("div");
    a.className = "prediction-percentage", a.textContent = "0%", n.appendChild(r), s.appendChild(o), s.appendChild(n), s.appendChild(a), M.appendChild(s)
  })
}

function U() {
  const M = document.getElementById("instructionsOverlay"),
    e = document.getElementById("mobileInstructionsOverlay");
  window.innerWidth <= 1024 ? (M.style.display = "none", e.style.display = "block", setTimeout(() => {
    e.classList.add("fade-out"), setTimeout(() => {
      e.style.display = "none"
    }, 1e3)
  }, 3e3), e.addEventListener("click", () => {
    e.classList.add("fade-out"), setTimeout(() => {
      e.style.display = "none"
    }, 1e3)
  })) : (e.style.display = "none", setTimeout(() => {
    M.classList.add("fade-out"), setTimeout(() => {
      M.style.display = "none"
    }, 1e3)
  }, 4e3), M.addEventListener("click", () => {
    M.classList.add("fade-out"), setTimeout(() => {
      M.style.display = "none"
    }, 1e3)
  }))
}

function O() {
  const M = document.getElementById("infoButton"),
    e = document.getElementById("infoModal"),
    t = document.getElementById("closeInfoModal");
  M.addEventListener("click", () => {
    e.classList.add("show")
  }), t.addEventListener("click", () => {
    e.classList.remove("show")
  }), e.addEventListener("click", i => {
    i.target === e && e.classList.remove("show")
  }), document.addEventListener("keydown", i => {
    i.key === "Escape" && e.classList.contains("show") && e.classList.remove("show")
  })
}

function B(M, e) {
  const t = document.getElementById("predictionChart"),
    i = window.innerWidth <= 1024;
  M.forEach((s, o) => {
    const n = t.querySelector(`[data-digit="${o}"]`);
    if (n) {
      const r = n.querySelector(".prediction-bar"),
        a = n.querySelector(".prediction-percentage"),
        l = n.querySelector(".prediction-bar-track"),
        c = (s * 100).toFixed(1);
      if (i) {
        r.style.height = `${c}%`, r.style.width = "100%", a.style.display = "block";
        const d = l.offsetHeight,
          u = c / 100 * d,
          h = d - u - 12;
        a.style.top = `${Math.max(-2,h)}px`
      } else r.style.width = `${c}%`, r.style.height = "100%", a.style.top = "", a.style.display = "block";
      a.textContent = `${c}%`, o === e.class ? r.classList.add("highest") : r.classList.remove("highest")
    }
  })
}
window.addEventListener("predictionUpdate", M => {
  const {
    probabilities: e,
    prediction: t
  } = M.detail;
  B(e, t)
});

function A() {
  if (window.innerWidth <= 1024) return;
  const M = document.getElementById("mnistImagesContainer"),
    e = Array.from({
      length: 300
    }, (i, s) => s),
    t = [];
  for (let i = 0; i < 180; i++) {
    const s = Math.floor(Math.random() * e.length);
    t.push(e.splice(s, 1)[0])
  }
  t.forEach(i => {
    const s = document.createElement("div");
    s.className = "mnist-sample-image";
    const o = document.createElement("img");
    o.src = `mnist_images/mnist_${i}.jpg`, o.alt = `MNIST Sample ${i}`, o.loading = "lazy", o.onerror = () => {
      s.style.display = "none"
    }, s.appendChild(o), M.appendChild(s)
  })
}
document.addEventListener("DOMContentLoaded", () => {
  G(), U(), O(), A()
});